<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Math√©matiques pour l'Intelligence Artificielle - Guide Progressif</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Georgia', serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
            text-align: center;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }
        
        h1 {
            color: #2c3e50;
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .subtitle {
            color: #7f8c8d;
            font-size: 1.2em;
            font-style: italic;
        }
        
        .section {
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        
        .section:hover {
            transform: translateY(-5px);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.15);
        }
        
        h2 {
            color: #2c3e50;
            font-size: 2em;
            margin-bottom: 20px;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }
        
        h3 {
            color: #34495e;
            font-size: 1.5em;
            margin: 20px 0 15px 0;
        }
        
        .level-indicator {
            display: inline-block;
            background: linear-gradient(45deg, #FF6B6B, #4ECDC4);
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9em;
            margin-bottom: 15px;
            font-weight: bold;
        }
        
        .concept-box {
            background: linear-gradient(135deg, #74b9ff, #0984e3);
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }
        
        .formula {
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            text-align: center;
            font-size: 1.1em;
        }
        
        .visualization {
            background: #fff;
            border: 1px solid #ddd;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        
        .interactive-demo {
            background: linear-gradient(135deg, #a8edea, #fed6e3);
            border-radius: 15px;
            padding: 25px;
            margin: 20px 0;
            text-align: center;
        }
        
        button {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1em;
            margin: 10px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }
        
        .progress-bar {
            background: #ecf0f1;
            height: 8px;
            border-radius: 4px;
            overflow: hidden;
            margin: 20px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transition: width 0.3s ease;
        }
        
        canvas {
            border: 2px solid #3498db;
            border-radius: 10px;
            margin: 10px 0;
        }
        
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        
        .card {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease;
        }
        
        .card:hover {
            transform: scale(1.05);
        }
        
        .highlight {
            background: linear-gradient(120deg, #a8edea 0%, #fed6e3 100%);
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: bold;
        }
        
        .connection-arrow {
            text-align: center;
            font-size: 2em;
            color: #3498db;
            margin: 20px 0;
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            .section {
                padding: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üß† Math√©matiques pour l'Intelligence Artificielle</h1>
            <p class="subtitle">Un parcours progressif du lyc√©e aux mod√®les d'IA</p>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill" style="width: 0%"></div>
            </div>
        </header>

        <!-- Niveau 1: Fondations Lyc√©e -->
        <section class="section" id="level1">
            <div class="level-indicator">Niveau 1 - Fondations Lyc√©e</div>
            <h2>üéØ Les Fondations Math√©matiques</h2>
            
            <h3>1. Fonctions et Graphiques</h3>
            <div class="concept-box">
                <p>Une fonction f(x) associe √† chaque valeur x une unique valeur y = f(x). Imaginez une machine: vous lui donnez une entr√©e (x), et elle vous donne une sortie (y). En IA, les fonctions sont partout, elles d√©crivent les relations entre les donn√©es et les pr√©dictions. Comprendre comment elles se comportent et comment les visualiser est la premi√®re √©tape pour appr√©hender les mod√®les complexes.</p>
            </div>
            
            <div class="visualization">
                <h4>Visualisation: Fonction Lin√©aire</h4>
                <canvas id="linearCanvas" width="400" height="300"></canvas>
                <p>f(x) = 2x + 1</p>
            </div>
            
            <h3>2. √âquations et Syst√®mes</h3>
            <div class="formula">
                Syst√®me d'√©quations:<br>
                2x + 3y = 7<br>
                x - y = 1
            </div>
            
            <div class="interactive-demo">
                <h4>üí° Pourquoi c'est important pour l'IA?</h4>
                <p>Les √©quations et syst√®mes d'√©quations sont fondamentaux pour mod√©liser des probl√®mes o√π plusieurs variables interagissent. En IA, notamment dans les r√©seaux de neurones, chaque neurone effectue des calculs bas√©s sur des syst√®mes d'√©quations lin√©aires, o√π les 'poids' et les 'biais' sont les coefficients que le mod√®le apprend. R√©soudre ces syst√®mes, c'est trouver les valeurs des variables qui satisfont toutes les conditions simultan√©ment.</p>
                <button onclick="showConnection(1)">Voir la connexion</button>
                <div id="connection1" style="display: none; margin-top: 15px; padding: 15px; background: rgba(255,255,255,0.3); border-radius: 10px;">
                    <p>Un neurone calcule: sortie = f(poids‚ÇÅ√óentr√©e‚ÇÅ + poids‚ÇÇ√óentr√©e‚ÇÇ + biais)</p>
                </div>
            </div>
        </section>

        <!-- Niveau 2: Calcul Diff√©rentiel -->
        <section class="section" id="level2">
            <div class="level-indicator">Niveau 2 - Calcul Diff√©rentiel</div>
            <h2>üìà D√©riv√©es et Optimisation</h2>
            
            <h3>1. Concept de D√©riv√©e</h3>
            <div class="concept-box">
                <p>La d√©riv√©e est un outil puissant qui mesure le taux de changement instantan√© d'une fonction. Imaginez que vous conduisez une voiture: la d√©riv√©e de votre position par rapport au temps est votre vitesse. En IA, la d√©riv√©e est cruciale pour l'optimisation, car elle nous indique dans quelle direction et √† quelle vitesse nous devons ajuster les param√®tres d'un mod√®le pour minimiser son erreur.</p>
            </div>
            
            <div class="formula">
                f'(x) = lim(h‚Üí0) [f(x+h) - f(x)] / h
            </div>
            
            <div class="visualization">
                <h4>Visualisation: D√©riv√©e d'une Fonction</h4>
                <canvas id="derivativeCanvas" width="400" height="300"></canvas>
                <button onclick="animateDerivative()">Animer la d√©riv√©e</button>
            </div>
            
            <h3>2. Optimisation</h3>
            <div class="grid">
                <div class="card">
                    <h4>Minimum Global</h4>
                    <p>Point o√π f'(x) = 0 et f''(x) > 0</p>
                    <canvas id="minCanvas" width="250" height="200"></canvas>
                </div>
                <div class="card">
                    <h4>Maximum Global</h4>
                    <p>Point o√π f'(x) = 0 et f''(x) < 0</p>
                    <canvas id="maxCanvas" width="250" height="200"></canvas>
                </div>
            </div>
            
            <div class="interactive-demo">
                <h4>üîó Application en IA: Descente de Gradient</h4>
                <p>L'optimisation est le processus de trouver les meilleures valeurs pour les param√®tres d'un mod√®le afin de minimiser ou maximiser une certaine fonction (souvent une fonction de co√ªt ou d'erreur). En IA, cela se traduit par l'ajustement des poids et des biais d'un r√©seau de neurones pour qu'il fasse les pr√©dictions les plus pr√©cises possibles. La descente de gradient, un algorithme cl√© en IA, utilise les d√©riv√©es pour naviguer dans le paysage de la fonction de co√ªt et trouver son minimum.</p>
                <button onclick="showGradientDescent()">Voir l'algorithme</button>
                <div id="gradientDemo" style="display: none;">
                    <canvas id="gradientCanvas" width="400" height="300"></canvas>
                    <p>L'algorithme "descend" vers le minimum en suivant la pente (d√©riv√©e)</p>
                </div>
            </div>
        </section>

        <!-- Niveau 3: Alg√®bre Lin√©aire -->
        <section class="section" id="level3">
            <div class="level-indicator">Niveau 3 - Alg√®bre Lin√©aire</div>
            <h2>üî¢ Vecteurs et Matrices</h2>
            
            <h3>1. Vecteurs</h3>
            <div class="concept-box">
                <p>Un vecteur est une entit√© math√©matique qui poss√®de √† la fois une magnitude (longueur) et une direction. Imaginez une fl√®che dans l'espace. En IA, les vecteurs sont omnipr√©sents: une image peut √™tre repr√©sent√©e comme un vecteur de pixels, un mot comme un vecteur s√©mantique, et les caract√©ristiques d'un individu (√¢ge, taille, poids) peuvent former un vecteur. Travailler avec des vecteurs permet de manipuler de grandes quantit√©s de donn√©es de mani√®re efficace.</p>
            </div>
            
            <div class="visualization">
                <h4>Visualisation: Vecteurs dans l'espace</h4>
                <canvas id="vectorCanvas" width="400" height="300"></canvas>
                <p>Vecteur v = [3, 2] repr√©sent√© dans le plan</p>
            </div>
            
            <h3>2. Matrices</h3>
            <div class="formula">
                <p>Une matrice est un tableau rectangulaire de nombres, organis√© en lignes et en colonnes. Elles sont essentielles en IA car elles permettent de repr√©senter et de manipuler des ensembles de donn√©es complexes, ainsi que les transformations lin√©aires appliqu√©es √† ces donn√©es. Par exemple, les poids des connexions entre les neurones dans un r√©seau de neurones sont souvent stock√©s sous forme de matrices, et les op√©rations sur ces matrices sont au c≈ìur du fonctionnement des mod√®les d'IA.</p>
            </div>
            
            <div class="interactive-demo">
                <h4>üéØ Multiplication Matricielle</h4>
                <div class="grid">
                    <div class="card">
                        <h4>Matrice A (2√ó2)</h4>
                        <div style="font-family: monospace;">
                            [2 1]<br>
                            [3 4]
                        </div>
                    </div>
                    <div class="card">
                        <h4>Vecteur v (2√ó1)</h4>
                        <div style="font-family: monospace;">
                            [5]<br>
                            [6]
                        </div>
                    </div>
                    <div class="card">
                        <h4>R√©sultat A√óv</h4>
                        <div style="font-family: monospace;">
                            [16]<br>
                            [39]
                        </div>
                    </div>
                </div>
                <button onclick="animateMatrixMultiplication()">Animer le calcul</button>
            </div>
            
            <h3>3. Application en IA</h3>
            <div class="concept-box">
                <p>Dans un r√©seau de neurones, chaque couche effectue: <span class="highlight">sortie = Matrice √ó entr√©e + biais</span></p>
            </div>
        </section>

        <!-- Niveau 4: Probabilit√©s et Statistiques -->
        <section class="section" id="level4">
            <div class="level-indicator">Niveau 4 - Probabilit√©s</div>
            <h2>üé≤ Probabilit√©s et Statistiques</h2>
            
            <h3>1. Probabilit√©s de Base</h3>
            <div class="concept-box">
                <p>Les probabilit√©s sont la branche des math√©matiques qui √©tudie le hasard et l'incertitude. Elles nous permettent de quantifier la chance qu'un √©v√©nement se produise. En IA, les probabilit√©s sont fondamentales pour de nombreuses t√¢ches, comme la classification (quelle est la probabilit√© que cette image contienne un chat ?), la pr√©diction (quelle est la probabilit√© que le prix d'une action augmente demain ?), et la prise de d√©cision sous incertitude. Comprendre les concepts de base comme la distribution normale est essentiel pour interpr√©ter les r√©sultats des mod√®les d'IA.</p>
            </div>
            
            <div class="visualization">
                <h4>Distribution Normale (Courbe en Cloche)</h4>
                <canvas id="normalCanvas" width="400" height="300"></canvas>
                <p>Œº = moyenne, œÉ = √©cart-type</p>
            </div>
            
            <h3>2. Th√©or√®me de Bayes</h3>
            <div class="formula">
                <p>Le Th√©or√®me de Bayes est une formule fondamentale en probabilit√©s qui permet de mettre √† jour la probabilit√© d'un √©v√©nement en fonction de nouvelles informations. Il est crucial en IA pour les syst√®mes de classification, les filtres anti-spam, les diagnostics m√©dicaux, et tout domaine o√π l'on doit inf√©rer des causes √† partir d'effets observ√©s. Il nous aide √† comprendre comment nos croyances sur un √©v√©nement changent lorsque nous obtenons de nouvelles preuves.</p>
                <button onclick="showBayesExample()">Voir l'exemple</button>
                <div id="bayesExample" style="display: none; margin-top: 15px;">
                    <p>Si 1% de la population a la maladie, et le test a 99% de pr√©cision:</p>
                    <p>P(Maladie|Test+) ‚âà 50% seulement!</p>
                </div>
            </div>
        </section>

        <!-- Niveau 5: Fonctions Sp√©ciales -->
        <section class="section" id="level5">
            <div class="level-indicator">Niveau 5 - Fonctions d'Activation</div>
            <h2>‚ö° Fonctions d'Activation</h2>
            
            <h3>1. Fonction Sigmo√Øde</h3>
            <div class="formula">
                <p>La fonction Sigmo√Øde est une fonction d'activation couramment utilis√©e dans les r√©seaux de neurones, notamment dans les couches de sortie pour les probl√®mes de classification binaire. Elle prend n'importe quelle valeur r√©elle en entr√©e et la transforme en une valeur entre 0 et 1, ce qui peut √™tre interpr√©t√© comme une probabilit√©. Sa forme en 'S' permet de compresser les grandes plages de valeurs en une sortie limit√©e, ce qui est utile pour mod√©liser des ph√©nom√®nes non lin√©aires.</p>
            </div>
            
            <div class="visualization">
                <h4>Comparaison des Fonctions d'Activation</h4>
                <canvas id="activationCanvas" width="400" height="300"></canvas>
                <div style="margin-top: 10px;">
                    <button onclick="showActivation('sigmoid')">Sigmo√Øde</button>
                    <button onclick="showActivation('relu')">ReLU</button>
                    <button onclick="showActivation('tanh')">Tanh</button>
                </div>
            </div>
            
            <h3>2. Fonction ReLU</h3>
            <div class="concept-box">
                <p>La fonction ReLU (Rectified Linear Unit) est une autre fonction d'activation tr√®s populaire en IA, particuli√®rement dans les couches cach√©es des r√©seaux de neurones profonds. Sa simplicit√© (elle renvoie l'entr√©e si elle est positive, et z√©ro sinon) la rend tr√®s efficace en termes de calcul et aide √† r√©soudre le probl√®me de la disparition du gradient, ce qui permet d'entra√Æner des r√©seaux plus profonds et plus complexes.</p>
            </div>
        </section>

        <!-- Niveau 6: Concepts IA -->
        <section class="section" id="level6">
            <div class="level-indicator">Niveau 6 - Concepts IA</div>
            <h2>ü§ñ Comprendre les Mod√®les d'IA</h2>
            
            <h3>1. Perceptron Simple</h3>
            <div class="visualization">
                <h4>Architecture d'un Neurone</h4>
                <canvas id="neuronCanvas" width="400" height="300"></canvas>
                <p>Le perceptron est le bloc de construction le plus √©l√©mentaire d'un r√©seau de neurones. Il s'inspire du fonctionnement d'un neurone biologique. Il prend plusieurs entr√©es, les multiplie par des poids (qui repr√©sentent l'importance de chaque entr√©e), les additionne, ajoute un biais, puis applique une fonction d'activation pour produire une sortie. C'est le fondement de l'apprentissage automatique, capable de prendre des d√©cisions binaires simples.</p>
            </div>
            
            <h3>2. R√©seau de Neurones</h3>
            <div class="interactive-demo">
                <h4>üß† R√©seau Multicouche</h4>
                <canvas id="networkCanvas" width="500" height="300"></canvas>
                <p>Un r√©seau de neurones est une collection de perceptrons (neurones) organis√©s en couches. Les informations circulent d\'une couche √† l\'autre, chaque neurone traitant les donn√©es et les transmettant √† la couche suivante. Ces r√©seaux sont capables d\'apprendre des motifs complexes dans les donn√©es, ce qui les rend extr√™mement puissants pour des t√¢ches comme la reconnaissance d\'images, le traitement du langage naturel et bien d\'autres applications d\'IA. Plus il y a de couches, plus le r√©seau est profond et plus il peut apprendre des repr√©sentations abstraites des donn√©es.</p>
            </div>
            
            <h3>3. Apprentissage (Backpropagation)</h3>
            <div class="concept-box">
                <p>La r√©tropropagation (backpropagation) est l'algorithme cl√© qui permet aux r√©seaux de neurones d'apprendre. C'est un processus en deux √©tapes: d'abord, le r√©seau fait une pr√©diction et calcule l'erreur (la diff√©rence entre la pr√©diction et la vraie valeur). Ensuite, cette erreur est propag√©e √† l'envers √† travers le r√©seau, en utilisant le calcul diff√©rentiel pour d√©terminer comment chaque poids et biais a contribu√© √† l'erreur. Cela permet d'ajuster les poids de mani√®re it√©rative pour minimiser l'erreur globale du mod√®le.</p>
            </div>
            
            <div class="interactive-demo">
                <h4>üéØ Fonction de Co√ªt</h4>
                <canvas id="costCanvas" width="400" height="300"></canvas>
                <p>L'IA cherche √† minimiser cette fonction (comme trouver le fond d'une vall√©e)</p>
                <button onclick="runOptimization()">Lancer l'optimisation</button>
            </div>
        </section>

        <!-- Synth√®se -->
        <section class="section" id="synthesis">
            <div class="level-indicator">Synth√®se</div>
            <h2>üåü Tout est Connect√©!</h2>
            
            <div class="grid">
                <div class="card">
                    <h4>Fonctions ‚Üí Neurones</h4>
                    <p>Chaque neurone calcule une fonction</p>
                </div>
                <div class="card">
                    <h4>D√©riv√©es ‚Üí Apprentissage</h4>
                    <p>Les d√©riv√©es guident l'optimisation</p>
                </div>
                <div class="card">
                    <h4>Matrices ‚Üí Calculs</h4>
                    <p>Tous les calculs sont matriciels</p>
                </div>
                <div class="card">
                    <h4>Probabilit√©s ‚Üí D√©cisions</h4>
                    <p>L'IA calcule des probabilit√©s</p>
                </div>
            </div>
            
            <div class="connection-arrow">‚¨áÔ∏è</div>
            
            <div class="concept-box">
                <h3>üéâ F√©licitations!</h3>
                <p>Vous avez maintenant les outils math√©matiques pour comprendre comment fonctionnent les mod√®les d'IA. Chaque concept du lyc√©e trouve sa place dans l'intelligence artificielle!</p>
            </div>
        </section>
    </div>

    <script>
        // Variables globales
        let currentLevel = 1;
        const totalLevels = 6;
        let gradientAnimationId;
        let currentPoint = { x: 2, y: 0 };
        
        // Mise √† jour de la barre de progression
        function updateProgress() {
            const progress = (currentLevel / totalLevels) * 100;
            document.getElementById('progressFill').style.width = progress + '%';
        }
        
        // Fonction pour afficher les connexions
        function showConnection(level) {
            const element = document.getElementById('connection' + level);
            element.style.display = element.style.display === 'none' ? 'block' : 'none';
        }
        
        // Dessiner une fonction lin√©aire
        function drawLinearFunction() {
            const canvas = document.getElementById('linearCanvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Grille
            ctx.strokeStyle = '#ecf0f1';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 400; i += 40) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, 300);
                ctx.stroke();
            }
            for (let i = 0; i <= 300; i += 30) {
                ctx.beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(400, i);
                ctx.stroke();
            }
            
            // Axes
            ctx.strokeStyle = '#34495e';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(200, 0);
            ctx.lineTo(200, 300);
            ctx.moveTo(0, 150);
            ctx.lineTo(400, 150);
            ctx.stroke();
            
            // Fonction f(x) = 2x + 1
            ctx.strokeStyle = '#3498db';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, 250);
            ctx.lineTo(400, 50);
            ctx.stroke();
            
            // Labels
            ctx.fillStyle = '#34495e';
            ctx.font = '14px Arial';
            ctx.fillText('x', 380, 140);
            ctx.fillText('y', 210, 20);
            ctx.fillText('f(x) = 2x + 1', 10, 30);
        }
        
        // Dessiner la d√©riv√©e
        function drawDerivative() {
            const canvas = document.getElementById('derivativeCanvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Grille
            ctx.strokeStyle = '#ecf0f1';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 400; i += 40) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, 300);
                ctx.stroke();
            }
            for (let i = 0; i <= 300; i += 30) {
                ctx.beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(400, i);
                ctx.stroke();
            }
            
            // Axes
            ctx.strokeStyle = '#34495e';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(200, 0);
            ctx.lineTo(200, 300);
            ctx.moveTo(0, 150);
            ctx.lineTo(400, 150);
            ctx.stroke();
            
            // Fonction f(x) = 0.01x¬≤ - 2x + 150
            ctx.strokeStyle = '#e74c3c';
            ctx.lineWidth = 3;
            ctx.beginPath();
            let first = true;
            for (let x = 0; x <= 400; x += 5) {
                const xVal = (x - 200) / 20;
                const y = 0.5 * xVal * xVal * 20 + 150;
                
                if (first) {
                    ctx.moveTo(x, y);
                    first = false;
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.stroke();
            
            // Point et tangente
            const pointX = 280;
            const pointY = 170;
            
            ctx.fillStyle = '#2ecc71';
            ctx.beginPath();
            ctx.arc(pointX, pointY, 5, 0, 2 * Math.PI);
            ctx.fill();
            
            // Tangente
            ctx.strokeStyle = '#2ecc71';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(pointX - 60, pointY + 30);
            ctx.lineTo(pointX + 60, pointY - 30);
            ctx.stroke();
            
            // Labels
            ctx.fillStyle = '#34495e';
            ctx.font = '14px Arial';
            ctx.fillText('f(x) = x¬≤', 10, 30);
            ctx.fillText('Tangente (d√©riv√©e)', 10, 50);
        }
        
        // Dessiner les vecteurs
        function drawVectors() {
            const canvas = document.getElementById('vectorCanvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Grille
            ctx.strokeStyle = '#ecf0f1';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 400; i += 40) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, 300);
                ctx.stroke();
            }
            for (let i = 0; i <= 300; i += 30) {
                ctx.beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(400, i);
                ctx.stroke();
            }
            
            // Axes
            ctx.strokeStyle = '#34495e';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(200, 0);
            ctx.lineTo(200, 300);
            ctx.moveTo(0, 150);
            ctx.lineTo(400, 150);
            ctx.stroke();
            
            // Vecteur [3, 2]
            ctx.strokeStyle = '#3498db';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(200, 150);
            ctx.lineTo(320, 70);
            ctx.stroke();
            
            // Fl√®che
            ctx.beginPath();
            ctx.moveTo(320, 70);
            ctx.lineTo(310, 80);
            ctx.moveTo(320, 70);
            ctx.lineTo(310, 65);
            ctx.stroke();
            
            // Labels
            ctx.fillStyle = '#34495e';
            ctx.font = '14px Arial';
            ctx.fillText('v = [3, 2]', 330, 60);
            ctx.fillText('0', 190, 170);
        }
        
        // Dessiner la distribution normale
        function drawNormalDistribution() {
            const canvas = document.getElementById('normalCanvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Grille
            ctx.strokeStyle = '#ecf0f1';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 400; i += 40) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, 300);
                ctx.stroke();
            }
            for (let i = 0; i <= 300; i += 30) {
                ctx.beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(400, i);
                ctx.stroke();
            }
            
            // Axes
            ctx.strokeStyle = '#34495e';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(200, 0);
            ctx.lineTo(200, 300);
            ctx.moveTo(0, 250);
            ctx.lineTo(400, 250);
            ctx.stroke();
            
            // Distribution normale
            ctx.strokeStyle = '#9b59b6';
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            let first = true;
            for (let x = 0; x <= 400; x += 5) {
                const xVal = (x - 200) / 60;
                const y = 150 * Math.exp(-0.5 * xVal * xVal) + 100;
                
                if (first) {
                    ctx.moveTo(x, 250 - y + 100);
                    first = false;
                } else {
                    ctx.lineTo(x, 250 - y + 100);
                }
            }
            ctx.stroke();
            
            // Labels
            ctx.fillStyle = '#34495e';
            ctx.font = '14px Arial';
            ctx.fillText('Œº', 190, 270);
            ctx.fillText('Distribution Normale', 10, 30);
        }
        
        // Dessiner les fonctions d'activation
        function drawActivationFunctions() {
            const canvas = document.getElementById('activationCanvas');
            if (!canvas) return;
            
            showActivation('sigmoid');
        }
        
        function showActivation(type) {
            const canvas = document.getElementById('activationCanvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Grille
            ctx.strokeStyle = '#ecf0f1';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 400; i += 40) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, 300);
                ctx.stroke();
            }
            for (let i = 0; i <= 300; i += 30) {
                ctx.beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(400, i);
                ctx.stroke();
            }
            
            // Axes
            ctx.strokeStyle = '#34495e';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(200, 0);
            ctx.lineTo(200, 300);
            ctx.moveTo(0, 150);
            ctx.lineTo(400, 150);
            ctx.stroke();
            
            ctx.strokeStyle = '#3498db';
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            if (type === 'sigmoid') {
                for (let x = 0; x <= 400; x++) {
                    const val = (x - 200) / 20;
                    const y = 1 / (1 + Math.exp(-val));
                    ctx.lineTo(x, 300 - (y * 200 + 50));
                }
                ctx.fillText('Sigmo√Øde', 10, 30);
            } else if (type === 'relu') {
                for (let x = 0; x <= 400; x++) {
                    const val = (x - 200) / 20;
                    const y = Math.max(0, val);
                    ctx.lineTo(x, 300 - (y * 200 + 50));
                }
                ctx.fillText('ReLU', 10, 30);
            } else if (type === 'tanh') {
                for (let x = 0; x <= 400; x++) {
                    const val = (x - 200) / 20;
                    const y = Math.tanh(val);
                    ctx.lineTo(x, 150 - (y * 100));
                }
                ctx.fillText('Tanh', 10, 30);
            }
            ctx.stroke();
        }
        
        // Dessiner le neurone
        function drawNeuron() {
            const canvas = document.getElementById('neuronCanvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Entr√©es
            ctx.fillStyle = '#2ecc71';
            ctx.beginPath();
            ctx.arc(50, 100, 10, 0, 2 * Math.PI);
            ctx.fill();
            ctx.fillText('x1', 20, 105);
            
            ctx.beginPath();
            ctx.arc(50, 150, 10, 0, 2 * Math.PI);
            ctx.fill();
            ctx.fillText('x2', 20, 155);
            
            ctx.beginPath();
            ctx.arc(50, 200, 10, 0, 2 * Math.PI);
            ctx.fill();
            ctx.fillText('x3', 20, 205);
            
            // Neurone
            ctx.fillStyle = '#3498db';
            ctx.beginPath();
            ctx.arc(200, 150, 30, 0, 2 * Math.PI);
            ctx.fill();
            ctx.fillStyle = 'white';
            ctx.fillText('Œ£', 195, 155);
            
            // Sortie
            ctx.fillStyle = '#e74c3c';
            ctx.beginPath();
            ctx.arc(350, 150, 10, 0, 2 * Math.PI);
            ctx.fill();
            ctx.fillText('y', 370, 155);
            
            // Connexions
            ctx.strokeStyle = '#34495e';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(60, 100);
            ctx.lineTo(170, 140);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(60, 150);
            ctx.lineTo(170, 150);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(60, 200);
            ctx.lineTo(170, 160);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(230, 150);
            ctx.lineTo(340, 150);
            ctx.stroke();
            
            // Poids
            ctx.fillStyle = '#34495e';
            ctx.font = '12px Arial';
            ctx.fillText('w1', 110, 120);
            ctx.fillText('w2', 110, 150);
            ctx.fillText('w3', 110, 180);
        }
        
        // Dessiner le r√©seau de neurones
        function drawNetwork() {
            const canvas = document.getElementById('networkCanvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const inputNodes = 3;
            const hiddenNodes = 4;
            const outputNodes = 2;
            
            const nodeRadius = 10;
            const layerSpacing = 150;
            const nodeSpacing = 50;
            
            // Dessiner les n≈ìuds
            function drawNode(x, y, color) {
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(x, y, nodeRadius, 0, 2 * Math.PI);
                ctx.fill();
            }
            
            // Dessiner les connexions
            function drawConnection(x1, y1, x2, y2) {
                ctx.strokeStyle = '#ccc';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }
            
            // Couche d'entr√©e
            const inputLayerX = 50;
            const inputNodePositions = [];
            for (let i = 0; i < inputNodes; i++) {
                const y = 150 - (inputNodes - 1) * nodeSpacing / 2 + i * nodeSpacing;
                drawNode(inputLayerX, y, '#2ecc71');
                inputNodePositions.push({ x: inputLayerX, y: y });
                ctx.fillStyle = '#333';
                ctx.fillText('Input ' + (i + 1), inputLayerX - 40, y + 3);
            }
            
            // Couche cach√©e
            const hiddenLayerX = inputLayerX + layerSpacing;
            const hiddenNodePositions = [];
            for (let i = 0; i < hiddenNodes; i++) {
                const y = 150 - (hiddenNodes - 1) * nodeSpacing / 2 + i * nodeSpacing;
                drawNode(hiddenLayerX, y, '#3498db');
                hiddenNodePositions.push({ x: hiddenLayerX, y: y });
                ctx.fillStyle = '#333';
                ctx.fillText('Hidden ' + (i + 1), hiddenLayerX - 40, y + 3);
            }
            
            // Couche de sortie
            const outputLayerX = hiddenLayerX + layerSpacing;
            const outputNodePositions = [];
            for (let i = 0; i < outputNodes; i++) {
                const y = 150 - (outputNodes - 1) * nodeSpacing / 2 + i * nodeSpacing;
                drawNode(outputLayerX, y, '#e74c3c');
                outputNodePositions.push({ x: outputLayerX, y: y });
                ctx.fillStyle = '#333';
                ctx.fillText('Output ' + (i + 1), outputLayerX - 40, y + 3);
            }
            
            // Dessiner les connexions
            for (const inputNode of inputNodePositions) {
                for (const hiddenNode of hiddenNodePositions) {
                    drawConnection(inputNode.x + nodeRadius, inputNode.y, hiddenNode.x - nodeRadius, hiddenNode.y);
                }
            }
            
            for (const hiddenNode of hiddenNodePositions) {
                for (const outputNode of outputNodePositions) {
                    drawConnection(hiddenNode.x + nodeRadius, hiddenNode.y, outputNode.x - nodeRadius, outputNode.y);
                }
            }
        }
        
        // Dessiner la fonction de co√ªt
        function drawCostFunction() {
            const canvas = document.getElementById('costCanvas');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Grille
            ctx.strokeStyle = '#ecf0f1';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 400; i += 40) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, 300);
                ctx.stroke();
            }
            for (let i = 0; i <= 300; i += 30) {
                ctx.beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(400, i);
                ctx.stroke();
            }
            
            // Axes
            ctx.strokeStyle = '#34495e';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(200, 0);
            ctx.lineTo(200, 300);
            ctx.moveTo(0, 250);
            ctx.lineTo(400, 250);
            ctx.stroke();
            
            // Fonction de co√ªt (parabolique)
            ctx.strokeStyle = '#e74c3c';
            ctx.lineWidth = 3;
            ctx.beginPath();
            let first = true;
            for (let x = 0; x <= 400; x += 5) {
                const xVal = (x - 200) / 50;
                const y = 50 * xVal * xVal + 50;
                
                if (first) {
                    ctx.moveTo(x, 250 - y);
                    first = false;
                } else {
                    ctx.lineTo(x, 250 - y);
                }
            }
            ctx.stroke();
            
            // Minimum
            ctx.fillStyle = '#2ecc71';
            ctx.beginPath();
            ctx.arc(200, 250 - 50, 7, 0, 2 * Math.PI);
            ctx.fill();
            ctx.fillText('Minimum', 210, 200);
            
            // Point actuel
            ctx.fillStyle = '#f39c12';
            ctx.beginPath();
            ctx.arc(currentPoint.x * 50 + 200, 250 - (50 * currentPoint.x * currentPoint.x + 50), 7, 0, 2 * Math.PI);
            ctx.fill();
            ctx.fillText('Point actuel', currentPoint.x * 50 + 210, 250 - (50 * currentPoint.x * currentPoint.x + 50) + 5);
        }
        
        // Animer la descente de gradient
        function runOptimization() {
            if (gradientAnimationId) {
                cancelAnimationFrame(gradientAnimationId);
            }
            currentPoint = { x: 2, y: 0 }; // R√©initialiser le point
            animateGradientDescent();
        }
        
        function animateGradientDescent() {
            const learningRate = 0.1;
            const derivative = 100 * currentPoint.x; // D√©riv√©e de 50x^2 + 50
            
            currentPoint.x -= learningRate * derivative;
            
            drawCostFunction();
            
            if (Math.abs(derivative) > 0.1) { // Arr√™ter quand la pente est proche de z√©ro
                gradientAnimationId = requestAnimationFrame(animateGradientDescent);
            } else {
                alert('Optimisation termin√©e! Minimum atteint.');
            }
        }
        
        // Dessiner les minimums/maximums
        function drawMinMax() {
            const minCanvas = document.getElementById('minCanvas');
            const maxCanvas = document.getElementById('maxCanvas');
            
            if (minCanvas) {
                const ctx = minCanvas.getContext('2d');
                ctx.clearRect(0, 0, minCanvas.width, minCanvas.height);
                ctx.strokeStyle = '#3498db';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, 100);
                ctx.bezierCurveTo(50, 200, 200, 0, 250, 100);
                ctx.stroke();
                ctx.fillStyle = '#2ecc71';
                ctx.beginPath();
                ctx.arc(125, 25, 5, 0, 2 * Math.PI);
                ctx.fill();
                ctx.fillText('Min', 135, 30);
            }
            
            if (maxCanvas) {
                const ctx = maxCanvas.getContext('2d');
                ctx.clearRect(0, 0, maxCanvas.width, maxCanvas.height);
                ctx.strokeStyle = '#e74c3c';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, 100);
                ctx.bezierCurveTo(50, 0, 200, 200, 250, 100);
                ctx.stroke();
                ctx.fillStyle = '#e74c3c';
                ctx.beginPath();
                ctx.arc(125, 175, 5, 0, 2 * Math.PI);
                ctx.fill();
                ctx.fillText('Max', 135, 170);
            }
        }
        
        // Initialisation
        window.onload = function() {
            updateProgress();
            drawLinearFunction();
            drawDerivative();
            drawVectors();
            drawNormalDistribution();
            drawActivationFunctions();
            drawNeuron();
            drawNetwork();
            drawCostFunction();
            drawMinMax();
        };
        
        // Mise √† jour de la progression au scroll (optionnel)
        window.addEventListener('scroll', () => {
            const sections = document.querySelectorAll('section.section');
            sections.forEach((section, index) => {
                const rect = section.getBoundingClientRect();
                if (rect.top <= window.innerHeight / 2 && rect.bottom >= window.innerHeight / 2) {
                    currentLevel = index + 1;
                    updateProgress();
                }
            });
        });
        
        // Fonctions pour les d√©mos interactives
        function showGradientDescent() {
            const demo = document.getElementById('gradientDemo');
            demo.style.display = demo.style.display === 'none' ? 'block' : 'none';
            if (demo.style.display === 'block') {
                drawCostFunction(); // Redessiner pour s'assurer que le canvas est pr√™t
            }
        }
        
        function animateMatrixMultiplication() {
            alert('Animation de la multiplication matricielle (√† impl√©menter)');
        }
        
        function showBayesExample() {
            const example = document.getElementById('bayesExample');
            example.style.display = example.style.display === 'none' ? 'block' : 'none';
        }
        
        function animateDerivative() {
            alert('Animation de la d√©riv√©e (√† impl√©menter)');
        }
    </script>
</body>
</html>

